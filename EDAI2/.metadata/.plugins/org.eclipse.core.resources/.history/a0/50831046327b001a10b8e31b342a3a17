package org.eda2;

import java.util.ArrayList;

/**
 * @author marta La representación de nuestro tablero viene dada por aristas
 */
public class Damero {
	private int filas;
	private int columnas;
	private ParEdificios[][] pEdificios;
	private ParEdificios[][] matrizMedias;
	public final static double CONSUMO_MINIMO = 300000; // m3 Son medidas que se dan en el enunciado
	public final static double CONSUMO_MAXIMO = 500000; // m3
	//Estas presiones solo para la casilla general
	public final static double PRESION_MAXIMA = 150;
	public final static double PRESION_MINIMA = 110;
	private ArrayList<Object> roturasContadorTroncal = new ArrayList<>(); 
	private ArrayList<Object> roturasContadorLineasD = new ArrayList<>(); 
	private ArrayList<Object> roturasProblemaRecursivo = new ArrayList<>(); //Lo pongo aqui porq si lo pongo en el problema con cada llamada recursiva
																			//se machaca todo lo que había y no va guardando resultados


	/**
	 * Nuestro Damero viene representado por pares de calles.
	 * 
	 * @param filas    el número de avenidas de nuestra ciudad
	 * @param columnas el número de calles de nuestra ciudad
	 */
	public Damero(int columnas, int filas) {
		Contador.reiniciarId(); 
		this.roturasContadorTroncal.clear();
		this.roturasContadorLineasD.clear();
		this.filas = filas;
		this.columnas = columnas;
		if (filas % 2 == 0) {
			pEdificios = new ParEdificios[columnas / 2][filas]; // i vale la mitad porque unimos dos columnas
			matrizMedias = new ParEdificios[columnas / 2][filas];
		} else {
			pEdificios = new ParEdificios[(columnas + 1) / 2][filas];
			matrizMedias = new ParEdificios[(columnas + 1) / 2][filas];
		}
		for (int a = 0; a < pEdificios.length; a++) {
			for (int b = 0; b < pEdificios[a].length; b++) {
				pEdificios[a][b] = new ParEdificios();
				matrizMedias[a][b] = new ParEdificios();
			}
		}
		
		this.inicializarContadores(this.pEdificios);
		this.inicializarContadores(this.matrizMedias);
		this.inicializarManometros();
	}
	
	

	/**
	 * @return la línea troncal de nuestro damero --> última fila, quitando la casilla general
	 */
	public ParEdificios[] lineaTroncal() {
		ParEdificios[] pE = new ParEdificios[pEdificios.length]; 
		for (int i = 0; i < pE.length; i++) {
			pE[i] = pEdificios[i][pEdificios[0].length - 1];
		}
		return pE;
	}

	/**
	 * @return la linea troncal de los datos de la media --> última fila, quitando la casilla general
	 */
	public ParEdificios[] lineaTroncalMedia() {
		ParEdificios[] pE = new ParEdificios[pEdificios.length];
		for (int i = 0; i < pE.length; i++) {
			pE[i] = matrizMedias[i][pEdificios[0].length - 1];
		}
		return pE;
	}
	

	/**
	 * @param i la linea que queremos obtener (existen diversas lineas de distribucion)
	 * @return dicha linea de distribucion
	 */
	public ParEdificios[] lineasDistribucion(int i){
		ParEdificios[] pE = new ParEdificios[this.pEdificios[0].length-1]; //Le quitamos la ultima fila (la troncal)
		
		for(int j=0; j<this.pEdificios[i].length-1; j++) {
			pE[j] = this.pEdificios[i][j];
		}
		
		return pE;
	}
	
	/**
	 * @param i la linea que queremos obtener (existen diversas lineas de distribucion)
	 * @return dicha linea de distribucion
	 */
	public ParEdificios[] lineasDistribucionMedias(int i){
		ParEdificios[] pE = new ParEdificios[this.matrizMedias[0].length-1]; //Le quitamos la ultima fila (la troncal)
		
		for(int j=0; j<this.matrizMedias[i].length-1; j++) {
			pE[j] = this.matrizMedias[i][j];
		}
		return pE;
	}
	

	/**
	 * @return nuestro damero de la ciudad
	 */
	public ParEdificios[][] getDamero() {
		return this.pEdificios;
	}
	
	
	/**
	 * @return las medias de la ciudad
	 */
	public ParEdificios[][] getMedias() {
		return this.matrizMedias;
	}
	
	public ArrayList<Object> getRoturasContadorTroncal() {
		return roturasContadorTroncal;
	}
	
	
	public ArrayList<Object> getRoturasContadorLineasD() {
		return roturasContadorLineasD;
	}
	
	// CONTADORES
	
	/**
	 * @param pEdificios la estructura que queremos inicializar. Así, nos sirve
	 *                   tanto para los datos actuales como para las medias
	 */
	private void inicializarContadores(ParEdificios[][] pEdificios) {
		// La primera fila tiene solo contadores morados, izq y der
		// El resto tiene verdes, izq y der
		// Lo inicializo todo a cero y cuando sepamos la cantidad inicial ya se la
		// asignamos a todos

		for (int i = 0; i < this.pEdificios.length; i++) {
			for (int j = 0; j < this.pEdificios[0].length; j++) {
				pEdificios[i][j] = new ParEdificios();
				pEdificios[i][j].setcDerecha(new Contador(0.0));
				pEdificios[i][j].setcIzquierda(new Contador(0.0));

				if (j == this.pEdificios[0].length - 1) { //En la casilla general no hay nada, solo un contador general
					pEdificios[i][j].setcMorado(new Contador(0.0));
				} else {
					pEdificios[i][j].setcVerde(new Contador(0.0));
				}
			}
		}

		if (this.filas % 2 == 0)
			this.inicializarContadoresPar(pEdificios);
		else
			this.inicializarContadoresImpar(pEdificios);
	}

	/**
	 * Terminamos de rellenar la última columna
	 */
	private void inicializarContadoresPar(ParEdificios[][] pEdificios) {
		int columnas = pEdificios.length - 1;
		for (int i = 0; i < pEdificios[0].length; i++) {
			pEdificios[columnas][i] = new ParEdificios();
			pEdificios[columnas][i].setcDerecha(new Contador(0.0));
			pEdificios[columnas][i].setcIzquierda(new Contador(0.0));

			if (i != pEdificios[0].length - 1)
				pEdificios[columnas][i].setcVerde(new Contador(0.0));
		}
	}

	/**
	 * La ultima columna la ponemos a null
	 */
	private void inicializarContadoresImpar(ParEdificios[][] pEdificios) {
		int columnas = pEdificios.length - 1;
		for (int i = 0; i < pEdificios[0].length; i++) {
			pEdificios[columnas][i] = new ParEdificios();
			pEdificios[columnas][i].setcIzquierda(new Contador(0.0));
			pEdificios[columnas][i].setcDerecha(null);
			if (i != pEdificios[0].length - 1)
				pEdificios[columnas][i].setcVerde(new Contador(0.0));
		}
	}

	public String toString() {
		String resultado = "";

		for (int j = 0; j < pEdificios[0].length; j++) {
			for (int i = 0; i < pEdificios.length; i++) {
				resultado += pEdificios[i][j].toString() + "(" + i + " ," + j + ")" + "\t" + " --> ";
			}
			resultado += "\n";
		}
		return resultado;
	}

	public String toStringMedias() {
		String resultado = "";

		for (int j = 0; j < this.matrizMedias[0].length; j++) {
			for (int i = 0; i < this.matrizMedias.length; i++) {
				resultado += this.matrizMedias[i][j].toString() + "(" + i + " ," + j + ")" + "\t" + " --> ";
			}
			resultado += "\n";
		}
		return resultado;
	}

	/**
	 * El usuario desconoce la estructura ParEdificios y va a insertar la dirección
	 * de una manzana con respecto al damero total
	 * 
	 * @param i filas a hallar
	 * @return un ArrayList en cuya primera posicion insertamos el indice y en la
	 *         segunda si el resultado de si el indice que nos pasaron era par. Si
	 *         es par accederemos a la casilla de la izquierda; si es impar a la de
	 *         la derecha
	 */
	private ArrayList<Object> traducirIndices(int i) {
		double division = i / 2;
		Boolean esPar = (division % 2 == 0) ? true : false;
		double nuevaFila = Math.floor(division);
		ArrayList<Object> solucion = new ArrayList<>();

		solucion.add(nuevaFila);
		solucion.add(esPar);

		return solucion;
	}

	/**
	 * Dada una casilla, saber cuánto ha consumido
	 * @param i
	 * @param j
	 * @return lo que ha connsumido la manzana i,j
	 */
	public double getLitrosEdificio(int i, int j, ParEdificios[][] pEdificios) { // columnas, filas
		i--;
		j--;
		double filas = (double) this.traducirIndices(i).get(0);
		boolean par = (boolean) this.traducirIndices(i).get(1);

		if (filas > this.filas / 2 || i > this.columnas) {
			throw new IndexOutOfBoundsException( "Debe introducir un edificio válido. Compruebe que los índices son correctos.");
		}
		
		//Si el tablero es par
		if(this.columnas % 2 == 0) { //par es si la columna a la que accedemos es par
			return (par == true) ? pEdificios[(int) filas][j].getcIzquierda().getConsumo() : pEdificios[(int) filas][j].getcDerecha().getConsumo();
		} else { // Si no estamos en un tablero par 
			//Tenemos que ver si la posicion a la que queremos acceder es la ultima casilla, si es la ultima casilla 
			//no es derecha, es izquierda, porq la derecha esta a null 
			if((int) filas == this.pEdificios.length-1 && j == this.pEdificios[0].length-1) {
				return pEdificios[(int)filas][j].getcIzquierda().getConsumo();
			} else {
				return (par == true) ? pEdificios[(int) filas][j].getcIzquierda().getConsumo() : pEdificios[(int) filas][j].getcDerecha().getConsumo();
			}
		}
	}


	/**
	 * @return la suma de los litros de todas las casillas sin tener en cuenta la
	 *         capacidad de la casilla general generadora
	 */
	public double getLitrosCasillasSalvoCasillaGeneral() {
		double resultado = 0;

		for (int i = 0; i < this.columnas / 2; i++) {
			for (int j = 0; j < this.filas; j++) {
				if (i == (this.columnas / 2) - 1 && j == this.filas - 1) break; // La general no
				resultado += this.pEdificios[i][j].getcDerecha().getConsumo() + this.pEdificios[i][j].getcIzquierda().getConsumo();
			}
		}
		return resultado;
	}

	/**
	 * @return un ArrayList de Object en el que guardaremos el contador que ha provocado una rotura de segundo grado en la linea troncal. 
	 * (ID, Contador)
	 */
	public ArrayList<Object> consumoExcesivoTroncal() {
		ArrayList<Object> resultado = new ArrayList<>();
		int i = 0;
		int j = this.lineaTroncal().length-1;
		
		roturasProblemaRecursivo.clear();
		resultado = this.consumoExcesivoRec(this.lineaTroncal(),this.lineaTroncalMedia(), i, j);
		
		if(!resultado.isEmpty()) this.roturasContadorTroncal.addAll(resultado);
		
		return resultado;
	}

	
	/**
	 * @return un ArrayList de Object en el que guardaremos el contador que ha provocado una rotura de segundo grado en las lineas de distribucion.
	 *  (ID, Contador)
	 */
	public ArrayList<Object> consumoExcesivoLineasDistribucion(){
		ArrayList<Object> resultado = new ArrayList<>();
		int tamMax = this.pEdificios.length;
		
		roturasProblemaRecursivo.clear();

		for(int i=0; i<tamMax; i++) { //Para cada columna llamamos al metodo consumoExcesivoRec 
			resultado = this.consumoExcesivoRec(lineasDistribucion(i),lineasDistribucionMedias(i), 0, lineasDistribucion(i).length-1);
			if(!resultado.isEmpty()) roturasContadorLineasD.addAll(resultado);
		}
		return roturasContadorLineasD;
	}
	
	/**
	 * Nuestro algoritmo recursivo va a dividir el problema hasta el máximo. Es decir, vamos a coger nuestro array de parEdificios 
	 * y vamos a simplificarlo hasta quedarnos con un solo par. Sobre este par podemos ver si se dan las condiciones necesarias 
	 * para que se produzca una rotura
	 * @param pE es la estructura a la que vamos a buscarle roturas de contadores
	 * @param i posicion inicial a partir de la cual vamos a empzar a buscar
	 * @param j posicion final de la búsqueda
	 * @return un ArrayList con todos los contadores que han presentado una rotura
	 */
	private ArrayList<Object> consumoExcesivoRec(ParEdificios[] pE, ParEdificios[] media, int i, int j) {
		int mitad;

		//Le voy a añadir un ID al Contador porque luego para buscarlo y decir en que casilla se encuentra creo que es lo mas 
		//rapido para buscarlo en funcion de esto
		
		
		//Lo que devuelve el ArrayList<Object>: 
		//1º -> Su ID (Como despues tenemos que hacer un estudio algoritmico de este metodo solo le metemos el ID para que no 
				//sea muy costoso. Luego hacemos un metodo que en función del ID nos diga donde se ubica el contador
		//2º -> El contador que ha provocado una rotura
		
		if (i == j) { // Caso base
			if(pE[i].getcDerecha() != null && pE[i].getcDerecha().getConsumo() > 7*media[i].getcDerecha().getConsumo()) {
					roturasProblemaRecursivo.add(pE[i].getcDerecha().getId());
					roturasProblemaRecursivo.add(pE[i].getcDerecha());
				
			}
			if(pE[i].getcIzquierda() != null && pE[i].getcIzquierda().getConsumo() > 7*media[i].getcIzquierda().getConsumo()) {
					roturasProblemaRecursivo.add(pE[i].getcIzquierda().getId());
					roturasProblemaRecursivo.add(pE[i].getcIzquierda());	
			}
			if(pE[i].getcMorado() != null && pE[i].getcMorado().getConsumo() > 7*media[i].getcMorado().getConsumo()) {
					roturasProblemaRecursivo.add(pE[i].getcMorado().getId());
					roturasProblemaRecursivo.add(pE[i].getcMorado());	
			}
			if(pE[i].getcVerde() != null && pE[i].getcVerde().getConsumo() > 7*media[i].getcVerde().getConsumo()) {
					roturasProblemaRecursivo.add(pE[i].getcVerde().getId());
					roturasProblemaRecursivo.add(pE[i].getcVerde());		
			}
			
		} else { // Casos recursivos
			mitad = (i + (j+1)) / 2;
			this.consumoExcesivoRec(pE, media, i, mitad - 1);
			this.consumoExcesivoRec(pE, media, mitad, j);
		}
		return roturasProblemaRecursivo;
	}
	
	/**
	 * @return una cadena con las casillas en las que se ha producido una rotura
	 */
	public String interpretarSolucionConsumoExcesivo(ArrayList<Object> consumo) {
		String cadena = "";
		int contador = 0;
		
		//Obtenemos el ID del contador y lo buscamos en nuestra matriz

		if(!consumo.isEmpty()) {
			for(Object o : consumo) {
				if(contador % 2 == 0) { //Solo nos interesa las posiciones pares
					Integer id = (Integer)o;
					
					for(int i=0; i<this.pEdificios.length; i++) {
						for(int j=0; j<this.pEdificios[i].length; j++) {
							if(Integer.compare(this.pEdificios[i][j].getcDerecha().getId(), id) == 0) {
								cadena += "* Casilla: [" + i+ ", " + j + "]. El contador derecha ha provocado la rotura\n";
							}
							if(Integer.compare(this.pEdificios[i][j].getcIzquierda().getId(), id) == 0) {
								cadena += "* Casilla: [" + i+ ", " + j + "]. El contador izquierda ha provocado la rotura\n";
							}
							if(this.pEdificios[i][j].getcMorado() != null && Integer.compare(this.pEdificios[i][j].getcMorado().getId(), id) == 0) {
								cadena += "* Casilla: [" + i+ ", " + j + "]. El contador morado ha provocado la rotura\n";
							}
							if(this.pEdificios[i][j].getcVerde() != null && Integer.compare(this.pEdificios[i][j].getcVerde().getId(), id) == 0) {
								cadena += "* Casilla: [" + i+ ", " + j + "]. El contador verde ha provocado la rotura\n";
							}
						}
					}
				} 
				contador++;
			}
		}

		return (cadena.isEmpty())? "No hay roturas.\n ": cadena;
	}
	

	// MANOMETROS
	private void inicializarManometros() {
			int ancho = pEdificios.length-1;
			int alto = pEdificios[0].length-1;
			double pAnterior, error;
			for(int j=pEdificios[0].length-1; j>=1; j--) {
				for(int i=pEdificios.length-1; i>=0; i--) {				
					if (i==ancho && j==alto) { //Manómetro general
						this.pEdificios[i][j].setMan(new Manometro(Math.random()*(PRESION_MINIMA-PRESION_MAXIMA+1)+PRESION_MAXIMA));
						continue;
					}
					//Obtenemos el valor de la presion del manometro anterior para obtener el siguiente a partir de él
					if (j==alto) pAnterior = this.pEdificios[i+1][j].getMan().getPresion();
					else pAnterior = this.pEdificios[i][j+1].getMan().getPresion();
					
					error = pAnterior - (pAnterior*13/100); //Margen de error del manometro
					this.pEdificios[i][j].setMan(new Manometro((Math.random()*(error-pAnterior+1)+pAnterior))); //Establecemos la presion del manómetro
				}
			}
		}

}
